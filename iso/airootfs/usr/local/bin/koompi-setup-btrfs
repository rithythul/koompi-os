#!/usr/bin/env bash
# KOOMPI Btrfs Setup Script
# Automates Btrfs filesystem creation and subvolume layout
# Part of KOOMPI OS immutability system

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
LABEL="koompi"
MOUNT_OPTIONS="defaults,noatime,compress=zstd:1,space_cache=v2,discard=async"

log() {
    echo -e "${GREEN}[$(date '+%H:%M:%S')]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    error "This script must be run as root"
fi

# Show usage
usage() {
    cat <<EOF
KOOMPI Btrfs Setup Script

Usage: koompi-setup-btrfs <device> [mount-point]

Arguments:
  device        Target device (e.g., /dev/sda, /dev/nvme0n1)
  mount-point   Optional mount point (default: /mnt)

Example:
  koompi-setup-btrfs /dev/sda
  koompi-setup-btrfs /dev/nvme0n1 /mnt/koompi

This script will:
  1. Partition the disk (EFI + Btrfs)
  2. Create Btrfs filesystem
  3. Create subvolumes (@, @home, @var, @snapshots)
  4. Generate /etc/fstab template
  5. Set up overlay for /etc (if requested)

WARNING: This will DESTROY all data on the target device!

EOF
}

# Partition disk with GPT
partition_disk() {
    local device=$1
    
    log "Partitioning $device..."
    
    # Wipe existing partition table
    wipefs -af "$device" || true
    sgdisk --zap-all "$device" || true
    
    # Create GPT partition table
    parted -s "$device" mklabel gpt
    
    # Create EFI partition (512MB)
    parted -s "$device" mkpart ESP fat32 1MiB 513MiB
    parted -s "$device" set 1 esp on
    
    # Create Btrfs partition (rest of disk)
    parted -s "$device" mkpart primary btrfs 513MiB 100%
    
    # Wait for kernel to recognize partitions
    sleep 2
    partprobe "$device"
    sleep 1
    
    log "Partitions created successfully"
}

# Get partition paths (handles both /dev/sda and /dev/nvme0n1 style)
get_partitions() {
    local device=$1
    
    if [[ $device =~ nvme ]]; then
        echo "${device}p1 ${device}p2"
    else
        echo "${device}1 ${device}2"
    fi
}

# Format partitions
format_partitions() {
    local efi_part=$1
    local btrfs_part=$2
    
    log "Formatting EFI partition..."
    mkfs.fat -F32 -n EFI "$efi_part"
    
    log "Formatting Btrfs partition..."
    mkfs.btrfs -f -L "$LABEL" "$btrfs_part"
    
    log "Partitions formatted successfully"
}

# Create Btrfs subvolumes
create_subvolumes() {
    local btrfs_part=$1
    local mount_point=$2
    
    log "Creating Btrfs subvolumes..."
    
    # Mount root of Btrfs filesystem
    mount "$btrfs_part" "$mount_point"
    
    # Create subvolumes
    btrfs subvolume create "$mount_point/@"
    btrfs subvolume create "$mount_point/@home"
    btrfs subvolume create "$mount_point/@var"
    btrfs subvolume create "$mount_point/.snapshots"
    
    # Create directory structure in @var for overlay
    mkdir -p "$mount_point/@var/lib/overlay/etc/upper"
    mkdir -p "$mount_point/@var/lib/overlay/etc/work"
    
    # Set default subvolume to @
    local subvol_id=$(btrfs subvolume list "$mount_point" | grep '@$' | awk '{print $2}')
    btrfs subvolume set-default "$subvol_id" "$mount_point"
    
    log "Subvolumes created successfully"
    
    # Unmount
    umount "$mount_point"
}

# Mount subvolumes
mount_subvolumes() {
    local btrfs_part=$1
    local efi_part=$2
    local mount_point=$3
    
    log "Mounting subvolumes..."
    
    # Mount @ as root
    mount -o "$MOUNT_OPTIONS,subvol=@" "$btrfs_part" "$mount_point"
    
    # Create mount points
    mkdir -p "$mount_point/home"
    mkdir -p "$mount_point/var"
    mkdir -p "$mount_point/.snapshots"
    mkdir -p "$mount_point/boot"
    
    # Mount other subvolumes
    mount -o "$MOUNT_OPTIONS,subvol=@home" "$btrfs_part" "$mount_point/home"
    mount -o "$MOUNT_OPTIONS,subvol=@var" "$btrfs_part" "$mount_point/var"
    mount -o "$MOUNT_OPTIONS,subvol=.snapshots" "$btrfs_part" "$mount_point/.snapshots"
    
    # Mount EFI partition
    mount "$efi_part" "$mount_point/boot"
    
    log "All subvolumes mounted"
}

# Generate fstab
generate_fstab() {
    local btrfs_part=$1
    local efi_part=$2
    local mount_point=$3
    
    log "Generating /etc/fstab..."
    
    local btrfs_uuid=$(blkid -s UUID -o value "$btrfs_part")
    local efi_uuid=$(blkid -s UUID -o value "$efi_part")
    
    cat > "$mount_point/etc/fstab" <<EOF
# /etc/fstab: static file system information
# Generated by koompi-setup-btrfs on $(date)

# <device>      <mount>      <type>  <options>       <dump> <pass>

# Btrfs root subvolume (will be read-only after installation)
UUID=$btrfs_uuid  /            btrfs   $MOUNT_OPTIONS,subvol=@  0 0

# Btrfs home subvolume
UUID=$btrfs_uuid  /home        btrfs   $MOUNT_OPTIONS,subvol=@home  0 0

# Btrfs var subvolume
UUID=$btrfs_uuid  /var         btrfs   $MOUNT_OPTIONS,subvol=@var  0 0

# Btrfs snapshots subvolume
UUID=$btrfs_uuid  /.snapshots  btrfs   $MOUNT_OPTIONS,subvol=.snapshots  0 0

# EFI System Partition
UUID=$efi_uuid    /boot        vfat    defaults,noatime  0 2

# Overlay for /etc (allows config changes on read-only root)
# Uncomment after setting root to read-only:
# overlay           /etc         overlay defaults,lowerdir=/etc,upperdir=/var/lib/overlay/etc/upper,workdir=/var/lib/overlay/etc/work  0 0
EOF

    log "fstab generated at $mount_point/etc/fstab"
}

# Display summary
show_summary() {
    local device=$1
    local mount_point=$2
    
    echo ""
    info "═══════════════════════════════════════════════════════"
    info "Btrfs Setup Complete!"
    info "═══════════════════════════════════════════════════════"
    echo ""
    log "Device: $device"
    log "Mount point: $mount_point"
    echo ""
    log "Subvolume layout:"
    btrfs subvolume list "$mount_point" | sed 's/^/  /'
    echo ""
    log "Disk usage:"
    df -h "$mount_point" | tail -1 | awk '{print "  Total: "$2", Used: "$3", Available: "$4", Use%: "$5}'
    echo ""
    log "Mount options: $MOUNT_OPTIONS"
    echo ""
    warn "Next steps:"
    echo "  1. Install base system: pacstrap $mount_point base linux-lts linux-firmware"
    echo "  2. Generate fstab: genfstab -U $mount_point >> $mount_point/etc/fstab"
    echo "  3. Chroot: arch-chroot $mount_point"
    echo "  4. Install bootloader and configure system"
    echo "  5. Set root to read-only in fstab (add 'ro' to @ mount options)"
    echo "  6. Enable /etc overlay (uncomment line in fstab)"
    echo ""
}

# Make root read-only (post-installation)
set_readonly() {
    local fstab=$1
    
    log "Setting root filesystem to read-only..."
    
    # Add 'ro' option to @ mount
    sed -i 's/subvol=@  0 0/subvol=@,ro  0 0/' "$fstab"
    
    # Uncomment overlay line
    sed -i 's/^# overlay/overlay/' "$fstab"
    
    log "Root set to read-only, /etc overlay enabled"
}

# Main function
main() {
    if [[ $# -lt 1 ]]; then
        usage
        exit 1
    fi
    
    local device=$1
    local mount_point=${2:-/mnt}
    
    # Verify device exists
    if [[ ! -b "$device" ]]; then
        error "Device $device does not exist"
    fi
    
    # Warning
    echo ""
    warn "═══════════════════════════════════════════════════════"
    warn "WARNING: This will DESTROY all data on $device!"
    warn "═══════════════════════════════════════════════════════"
    echo ""
    read -p "Type 'YES' to continue: " -r
    if [[ $REPLY != "YES" ]]; then
        log "Cancelled"
        exit 0
    fi
    
    echo ""
    log "Starting Btrfs setup on $device..."
    echo ""
    
    # Execute setup steps
    partition_disk "$device"
    
    read efi_part btrfs_part <<< $(get_partitions "$device")
    log "EFI partition: $efi_part"
    log "Btrfs partition: $btrfs_part"
    
    format_partitions "$efi_part" "$btrfs_part"
    create_subvolumes "$btrfs_part" "$mount_point"
    mount_subvolumes "$btrfs_part" "$efi_part" "$mount_point"
    
    # Create minimal directory structure
    mkdir -p "$mount_point/etc"
    
    generate_fstab "$btrfs_part" "$efi_part" "$mount_point"
    
    show_summary "$device" "$mount_point"
}

# Handle special commands
case "${1:-}" in
    --help|-h|help)
        usage
        exit 0
        ;;
    --set-readonly)
        if [[ $# -lt 2 ]]; then
            error "Usage: $0 --set-readonly <fstab-path>"
        fi
        set_readonly "$2"
        exit 0
        ;;
    *)
        main "$@"
        ;;
esac
